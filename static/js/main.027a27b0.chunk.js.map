{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/hooks/utils/getFieldFromContext.ts","../../src/hooks/useGoogleFormContext.tsx","../../src/hooks/utils/useCustomOptionField.ts","../../src/hooks/useGoogleForm.ts","../../src/hooks/utils/useTextInput.ts","../../src/hooks/utils/useGridInput.ts","../../src/hooks/useDropdownInput.ts","../../src/hooks/useLinearInput.ts","components/CheckboxInput.js","../../src/hooks/useCheckboxInput.ts","components/RadioInput.js","../../src/hooks/useRadioInput.ts","components/ShortAnswerInput.js","../../src/hooks/useShortAnswerInput.ts","components/LongAnswerInput.js","../../src/hooks/useLongAnswerInput.ts","components/RadioGridInput.js","../../src/hooks/useRadioGridInput.ts","components/CheckboxGridInput.js","../../src/hooks/useCheckboxGridInput.ts","components/DropdownInput.js","components/LinearGrid.js","App.js","index.jsx"],"names":["Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","context","Error","field","GoogleFormContext","React","useGoogleFormContext","GoogleFormProvider","children","other","value","getFieldFromContext","id","useState","customInputRequired","setCustomInputRequired","register","options","required","currentValue","useEffect","nonCustomOptions","o","buildId","slugify","registerOption","label","customOption","customOptionId","buildCustomFieldId","error","registerCustomInput","useGoogleForm","form","methods","useForm","fieldIndex","resolveField","fields","Object","formData","params","skipNull","skipEmptyString","a","GOOGLE_FORMS_URL","headers","errors","setErrors","lineId","newErrors","fieldError","l","acc","renderGrid","render","renderColumns","c","registerColumn","registerLine","useDropdownInput","useLinearInput","Container","styled","div","CheckboxContainer","CheckboxInput","useCustomOptionField","useCheckboxInput","map","key","type","htmlFor","placeholder","ErrorLabel","span","RadioInput","useRadioInput","ShortAnswerInput","useTextInput","useShortAnswerInput","LongAnswerInput","useLongAnswerInput","GridQuestionContainer","TableHeader","header","TableRow","TableCell","RadioGridInput","useGridInput","useRadioGridInput","columns","CheckboxGridInput","useCheckboxGridInput","DropdownInput","legend","labelFirst","labelLast","Form","QuestionContainer","QuestionLabel","h3","Questions","questionInput","App","onSubmit","data","console","log","submitToGoogleForms","alert","formState","handleSubmit","ReactDOM","document","getElementById"],"mappings":"wSAoK+D,qBAAXA,SAA0BA,OAAOC,WAAaD,OAAOC,SAAWD,OAAO,qBA6DvD,qBAAXA,SAA0BA,OAAOE,gBAAkBF,OAAOE,cAAgBF,OAAO,0BAiVnI,SAASG,EAAOC,EAAMC,GAC5B,IACC,IAAIC,EAASF,IACZ,MAAMG,GACP,OAAOF,EAAQE,GAEhB,OAAID,GAAUA,EAAOE,KACbF,EAAOE,UAAK,EAAQH,GAErBC,E,+MCzjBR,I,UAAA,EAAe,SAAC,EAAD,KAKb,UAAIG,EACF,MAAM,IAAIC,MAAV,wDAGF,IAAMC,EAAQF,WAAd,GAEA,GAAIE,SAAJ,EACE,MAAM,IAAID,MAAM,iBAAiBC,EAA3B,sBAAN,GAGF,U,eCdIC,EAAoBC,wBAA1B,MACaC,EAAuB,kBAAMD,qBAAN,IAEvBE,EAAqB,SAAC,G,IACjCC,aACGC,E,oIAAAA,MAIH,OACE,wBAACL,EAAD,UAA4BM,MAAOD,GADrC,ICSF,EAAe,SAAC,EAAD,GAIb,IAAMR,EAAUK,IACVH,EAAQQ,EAAoBV,EAASW,EAA3C,GAEA,EAAsDC,oBAAtD,GAAOC,EAAP,KAA4BC,EAA5B,KAEMC,EAAW,SAACC,GAAD,OACfhB,EAAA,cAAwBiB,SAAUf,EAAMe,UADzB,KAGXC,EAAelB,QAArB,GAEAmB,qBAAU,WACR,UAAIjB,OACFY,EACEZ,eAxBD,qBAwBmCgB,GAGpCJ,EACEZ,mBAEEgB,UACAA,WA/BH,uBAkCF,CAACA,EAbJC,IAeA,IAAMC,EAAmBlB,EAAA,gBACvB,mBAAQmB,EAAR,UAGIC,EAAU,SAACb,GACf,OAAUE,EAAV,IAAgBY,IAAhB,IAiBI1B,EAAS,CACbmB,QAASI,OAfiB,SAACC,GAC3B,IAAMV,EAAKW,EAAQD,EAAnB,OAMA,eAEEV,GAFF,EAGEa,eARqB,SAACR,GAAD,YAClBD,EAAS,EAAD,GADU,KAErBN,MAAOY,EAAEI,eAcPC,EAAexB,EAAA,cAAmB,mBAAOmB,EAAP,UACxC,KAAkB,CAChB,IAAMV,EAAKW,EAhER,oBAsEGK,EAnEwB,SAAChB,GACjC,OAAUA,2BAkEeiB,CAAvB,GASMC,EAAQ7B,mBAAd,GAEAH,uBAEEc,GAFFd,EAGE2B,eAnBqB,SAACR,GAAD,gBAACA,MAAD,SAClBD,EAAS,EAAD,GADU,KAErBN,MAnEC,sBAqFDqB,oBAb0B,SAACd,GAC3B,YAD2BA,UAAU,IAC9BhB,EAAA,cACLiB,SAAUJ,GADZ,KAaAgB,UAIJ,IAAMA,EAAQ7B,mBAA0BE,EAAxC,IAEA,iBAGE2B,WC3ESE,EAAgB,SAAC,G,IAAEC,SACxBC,EAAUC,cAEhBD,WAAmB,mBAzBA,SAACtB,EAAD,GACnB,IAAMwB,EAAaH,cAAnB,GAEA,YAAIG,EACF,MAAM,IAAIlC,MAAM,iBAAV,EAAN,8BAIF,OADc+B,SAAd,GAkBmCI,CAAazB,EAA7B,IAkCnB,OAFAsB,sBA9B4B,SAAH,OACvB,IAAMI,EAAN,GACAC,wBAA8B,YAlBA,IAAC3B,EAmB7B0B,GAnB6B1B,EAmB7B0B,EAlBA1B,WDTC,yBCUH,SAAgBA,oDAAhB,6BAMF,aAWsC4B,EAAlCF,MAGF,IAAMG,EAAS,gBAA8B,CAC3CC,UAD2C,EAE3CC,iBAAiB,I,gBAGf,uBACI,EAAAC,EAAA,IACDC,mCAAoBZ,EADnB,2CAEJ,CACEa,QAAS,CACP,eAAgB,wCALpB,wBASH,e,gEApBsB,oCAgCzB,GCjEF,EAAe,SAAC,EAAD,GAIb,IAAM7C,EAAUK,IAEVH,EAAQQ,EAAoBV,EAASW,EAA3C,GAEMkB,EAAQ7B,mBAA0BE,EAAxC,IAKA,eAAmBa,SAHF,SAACC,GAAD,OACfhB,EAAA,cAAwBiB,SAAUf,EAAMe,UADzB,KAGYY,WCL/B,EAAe,SAAC,EAAD,GAIb,IAAM7B,EAAUK,IAChB,EAA4BO,wBAA5B,GAAOkC,EAAP,KAAeC,EAAf,KAEM7C,EAAQQ,EAAoBV,EAASW,EAA3C,GAEMW,EAAU,SAAC0B,EAAD,GACd,OAAUrC,EAAV,UAA0BY,IAA1B,IAGFJ,qBAAU,WACR,IAAM8B,EAAwB/C,EAAA,cAAmB,cAC/C,IAAMgD,EAAalD,mBAA0BmD,EAA7C,IAIA,OAHA,IACEC,EAAID,EAAJC,OAEF,IALF,IAQId,sBAAJ,EACES,KAEAA,YAED,CAAC/C,YAdJmB,SAqCA,eAAmBkC,WArBA,SAACC,GAClB,OAAOpD,EAAA,WAAgB,YAgBrB,OAAOoD,EAAO,EAAD,MAASC,cAZA,SAACD,GACrB,OAAOpD,EAAA,aAAkB,YACvB,IAAMS,EAAKW,EAAQ6B,EAAD,GAAOK,EAAzB,OAMA,OAAOF,EAAO,EAAD,MAASG,eALC,SAACzC,GAAD,YANN,SAACA,GAAD,OACnBhB,EAAA,SAAkBmD,EAAlB,MAA0BlC,SAAUf,EAAMe,UADvB,IAOZyC,CADkB,IAErBjD,MAAO+C,EAAE/B,SAG2Bd,mBAQfmC,YCzDpBa,EAAmB,SAAChD,GAC/B,IAAMX,EAAUK,IAEVH,EAAQQ,EAAoBV,EAASW,EAA3C,YAKMkB,EAAQ7B,mBAA0BE,EAAxC,IAMMc,EAAUd,EAAA,aAAkB,YAChC,IALeO,EAMf,eAEEE,IARaF,EAKIY,EAAnB,MAJUnB,EAAV,OAAsBqB,IAAtB,SAWF,eAAmBP,QAAnB,EAA4BD,SAjBX,SAACC,GAAD,OACfhB,EAAA,cAAwBiB,SAAUf,EAAMe,UADzB,KAiBqBY,WCtB3B+B,EAAiB,SAACjD,GAC7B,IAAMX,EAAUK,IAEVH,EAAQQ,EAAoBV,EAASW,EAA3C,UAEMI,EAAW,SAACC,GAAD,OACfhB,EAAA,cAAwBiB,SAAUf,EAAMe,UADzB,KAOXY,EAAQ7B,mBAA0BE,EAAxC,IAEMc,EAAUd,EAAA,aAAkB,YAChC,IAPeO,EAOTE,GAPSF,EAOIY,EAAnB,MANUnB,EAAV,OAAsBqB,IAAtB,IAYA,eAEEZ,GAFF,EAGEa,eARqB,SAACR,GAAD,YAClBD,EADkB,IAErBN,MAAOY,EAAEI,cAUb,eAAmBT,QAAnB,EAA4Ba,W,QC9BxBgC,EAAYC,IAAOC,IAAV,yEAKTC,EAAoBF,IAAOC,IAAV,uFAQR,SAASE,EAAT,GAAgC,IAC7C,EChB8B,SAACtD,GAC/B,OAAOuD,EAAqBvD,EAA5B,YDekCwD,CADU,EAANxD,IAC9BK,EAAR,EAAQA,QAASU,EAAjB,EAAiBA,aAEjB,OACE,kBAACmC,EAAD,KACG7C,EAAQoD,KAAI,SAAC/C,GAAD,OACX,kBAAC2C,EAAD,CAAmBK,IAAKhD,EAAEV,IACxB,yCAAO2D,KAAK,WAAW3D,GAAIU,EAAEV,IAAQU,EAAEG,mBACvC,2BAAO+C,QAASlD,EAAEV,IAAKU,EAAEI,WAG5BC,GACC,kBAACsC,EAAD,KACE,yCACEM,KAAK,WACL3D,GAAIe,EAAaf,IACbe,EAAaF,mBAEnB,2BAAO+C,QAAS7C,EAAaf,IAA7B,SACA,yCACE2D,KAAK,OACLE,YAAY,iBACR9C,EAAaI,0BEnC7B,I,QAAM+B,EAAYC,IAAOC,IAAV,yEAKTC,EAAoBF,IAAOC,IAAV,uFAQjBU,EAAaX,IAAOY,KAAV,+DAKD,SAASC,EAAT,GAA6B,IAC1C,ECrB2B,SAAChE,GAC5B,OAAOuD,EAAqBvD,EAA5B,SDoByCiE,CADA,EAANjE,IAC3BK,EAAR,EAAQA,QAASU,EAAjB,EAAiBA,aAAcG,EAA/B,EAA+BA,MAE/B,OACE,kBAAC,EAAD,KACGb,EAAQoD,KAAI,SAAC/C,GAAD,OACX,kBAAC,EAAD,CAAmBgD,IAAKhD,EAAEV,IACxB,yCAAO2D,KAAK,QAAQ3D,GAAIU,EAAEV,IAAQU,EAAEG,mBACpC,2BAAO+C,QAASlD,EAAEV,IAAKU,EAAEI,WAG5BC,GACC,kBAAC,EAAD,KACE,yCACE4C,KAAK,QACL3D,GAAIe,EAAaf,IACbe,EAAaF,mBAEnB,2BAAO+C,QAAS7C,EAAaf,IAA7B,SACA,yCACE2D,KAAK,OACLE,YAAY,iBACR9C,EAAaI,yBAIvB,kBAAC2C,EAAD,KAAa5C,GAAS,2BE7Cb,SAASgD,EAAT,GAAmC,IACxC9D,ECHyB,SAACJ,GAClC,OAAOmE,EAAanE,EAApB,gBDEqBoE,CAD0B,EAANpE,IACjCI,SAER,OACE,6BACE,yCAAOuD,KAAK,QAAWvD,OELd,SAASiE,EAAT,GAAkC,IACvCjE,ECHwB,SAACJ,GACjC,OAAOmE,EAAanE,EAApB,eDEqBsE,CADyB,EAANtE,IAChCI,SAER,OACE,6BACE,4CAAUuD,KAAK,QAAWvD,OELhC,I,SAAMmE,GAAwBpB,IAAOC,IAAV,+CAIrBoB,GAAcrB,IAAOsB,OAAV,mDAIXC,GAAWvB,IAAOC,IAAV,mDAIRuB,GAAYxB,IAAOC,IAAV,qEAKA,SAASwB,GAAT,GAAiC,IAC9C,ECpB+B,SAAC5E,GAChC,OAAO6E,EAAa7E,EAApB,cDmBgC8E,CADa,EAAN9E,IAC/B+E,EAAR,EAAQA,QAASrC,EAAjB,EAAiBA,WAEjB,OACE,kBAAC6B,GAAD,KACE,kBAACC,GAAD,KACE,kBAACG,GAAD,MACCI,EAAQtB,KAAI,SAACZ,GAAD,OACX,kBAAC8B,GAAD,CAAWjB,IAAKb,EAAE/B,OAAQ+B,EAAE/B,WAG/B4B,GAAW,SAACF,GAAD,OACV,kBAACkC,GAAD,CAAUhB,IAAKlB,EAAE1B,OACf,kBAAC6D,GAAD,KAAYnC,EAAE1B,OACb0B,EAAEI,eAAc,SAACC,GAAD,OACf,kBAAC8B,GAAD,CAAWjB,IAAKb,EAAE/B,OAChB,yCAAO6C,KAAK,SAAYd,EAAEC,4BEjCxC,I,MAAMyB,GAAwBpB,IAAOC,IAAV,+CAIrBoB,GAAcrB,IAAOsB,OAAV,mDAIXC,GAAWvB,IAAOC,IAAV,mDAIRuB,GAAYxB,IAAOC,IAAV,uEAKA,SAAS4B,GAAT,GAAoC,IACjD,ECpBkC,SAAChF,GACnC,OAAO6E,EAAa7E,EAApB,iBDmBgCiF,CADgB,EAANjF,IAClC+E,EAAR,EAAQA,QAASrC,EAAjB,EAAiBA,WAEjB,OACE,kBAAC,GAAD,KACE,kBAAC,GAAD,KACE,kBAAC,GAAD,MACCqC,EAAQtB,KAAI,SAACZ,GAAD,OACX,kBAAC,GAAD,CAAWa,IAAKb,EAAE/B,OAAQ+B,EAAE/B,WAG/B4B,GAAW,SAACF,GAAD,OACV,kBAAC,GAAD,CAAUkB,IAAKlB,EAAE1B,OACf,kBAAC,GAAD,KAAY0B,EAAE1B,OACb0B,EAAEI,eAAc,SAACC,GAAD,OACf,kBAAC,GAAD,CAAWa,IAAKb,EAAE/B,OAChB,yCAAO6C,KAAK,YAAed,EAAEC,4BEjC5B,SAASoC,GAAT,GAAgC,IAAPlF,EAAM,EAANA,GACtC,EAA8BgD,EAAiBhD,GAAvCI,EAAR,EAAQA,SAAUC,EAAlB,EAAkBA,QAElB,OACE,6BACE,2BAAYD,IACV,4BAAQN,MAAM,IAAd,iBACCO,EAAQoD,KAAI,SAAC/C,GACZ,OACE,4BAAQgD,IAAKhD,EAAEI,MAAOhB,MAAOY,EAAEI,OAC5BJ,EAAEI,YCTjB,I,SAAMoC,GAAYC,IAAOC,IAAV,oIAUTU,GAAaX,IAAOY,KAAV,6CAID,SAASG,GAAT,GAAmC,IAAPlE,EAAM,EAANA,GACzC,EAAmCiD,EAAejD,GAA1CK,EAAR,EAAQA,QAAS8E,EAAjB,EAAiBA,OAAQjE,EAAzB,EAAyBA,MAEzB,OACE,oCACE,kBAAC,GAAD,KACE,6BAAMiE,EAAOC,YACZ/E,EAAQoD,KAAI,SAAC/C,GACZ,OAAO,yCAAOgD,IAAKhD,EAAEV,GAAI2D,KAAK,SAAYjD,EAAEG,sBAE9C,6BAAMsE,EAAOE,YAEf,kBAAC,GAAD,KAAanE,GAAS,2BCf5B,IAAMoE,GAAOnC,IAAO9B,KAAV,0FAMJkE,GAAoBpC,IAAOC,IAAV,sDAIjBoC,GAAgBrC,IAAOsC,GAAV,sDAIbC,GAAY,WAChB,OACE,6BACGrE,EAAKK,OAAO+B,KAAI,SAAClE,GAChB,IAAQS,EAAOT,EAAPS,GAEJ2F,EAAgB,KACpB,OAAQpG,EAAMoE,MACZ,IAAK,WACHgC,EAAgB,kBAACrC,EAAD,CAAetD,GAAIA,IACnC,MACF,IAAK,QACH2F,EAAgB,kBAAC3B,EAAD,CAAYhE,GAAIA,IAChC,MACF,IAAK,eACH2F,EAAgB,kBAACzB,EAAD,CAAkBlE,GAAIA,IACtC,MACF,IAAK,cACH2F,EAAgB,kBAACtB,EAAD,CAAiBrE,GAAIA,IACrC,MACF,IAAK,aACH2F,EAAgB,kBAACf,GAAD,CAAgB5E,GAAIA,IACpC,MACF,IAAK,gBACH2F,EAAgB,kBAACX,GAAD,CAAmBhF,GAAIA,IACvC,MACF,IAAK,WACH2F,EAAgB,kBAACT,GAAD,CAAelF,GAAIA,IACnC,MACF,IAAK,SACH2F,EAAgB,kBAAC,GAAD,CAAY3F,GAAIA,IAIpC,OAAK2F,EAKH,kBAACJ,GAAD,CAAmB7B,IAAK1D,GACtB,kBAACwF,GAAD,KAAgBjG,EAAMuB,OACrB6E,GANI,UAkCFC,GApBH,WACV,IAAMtE,EAAUF,EAAc,CAAEC,SAC1BwE,EAAQ,uCAAG,WAAOC,GAAP,SAAA9D,EAAA,6DACf+D,QAAQC,IAAI,uBAAwBF,GADrB,SAETxE,EAAQ2E,oBAAoBH,GAFnB,OAGfI,MAAM,gCAHS,2CAAH,sDAQd,OAFAH,QAAQC,IAAI,6BAA8B1E,EAAQ6E,UAAUhE,QAG1D,kBAAC,EAAuBb,EACtB,kBAACgE,GAAD,CAAMO,SAAUvE,EAAQ8E,aAAaP,IACnC,kBAAC,GAAD,MACA,4BAAQlC,KAAK,UAAb,eCtFR0C,IAAS1D,OAAO,kBAAC,GAAD,MAAS2D,SAASC,eAAe,U","file":"static/js/main.027a27b0.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { UseGoogleFormReturn, FieldTypes } from '../../types'\n\nexport default (\n  context: UseGoogleFormReturn | null,\n  id: string,\n  type: FieldTypes\n) => {\n  if (context === null) {\n    throw new Error('You need to wrap your form with a GoogleFormProvider')\n  }\n\n  const field = context.getField(id)\n\n  if (field.type !== type) {\n    throw new Error(`Field with id ${field.id} is not of type ${type}`)\n  }\n\n  return field\n}\n","import * as React from 'react'\nimport { UseGoogleFormReturn } from '../types'\n\nconst GoogleFormContext = React.createContext<UseGoogleFormReturn | null>(null)\nexport const useGoogleFormContext = () => React.useContext(GoogleFormContext)\n\nexport const GoogleFormProvider = ({\n  children,\n  ...other\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <GoogleFormContext.Provider value={other as UseGoogleFormReturn}>\n      {children}\n    </GoogleFormContext.Provider>\n  )\n}\n","import { useState, useEffect } from 'react'\nimport slugify from 'slugify'\n\nimport {\n  UseCustomOptionReturn,\n  Option,\n  BaseField,\n  UseCustomOptionField,\n  CustomOptionField\n} from '../../types'\nimport getFieldFromContext from './getFieldFromContext'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const OTHER_OPTION = '__other_option__'\nexport const OTHER_OPTION_RESPONSE = 'other_option_response'\n\nexport const buildCustomFieldId = (id: string) => {\n  return `${id}-${OTHER_OPTION_RESPONSE}`\n}\n\nexport default (\n  id: string,\n  type: 'CHECKBOX' | 'RADIO'\n): UseCustomOptionField => {\n  const context = useGoogleFormContext()\n  const field = getFieldFromContext(context, id, type) as CustomOptionField\n\n  const [customInputRequired, setCustomInputRequired] = useState<boolean>(false)\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const currentValue = context!.watch(id)\n\n  useEffect(() => {\n    if (field.type === 'RADIO') {\n      setCustomInputRequired(\n        field.required && currentValue && currentValue === OTHER_OPTION\n      )\n    } else {\n      setCustomInputRequired(\n        field.required &&\n          currentValue &&\n          currentValue.length === 1 &&\n          currentValue.includes(OTHER_OPTION)\n      )\n    }\n  }, [currentValue, customInputRequired])\n\n  const nonCustomOptions = field.options.filter(\n    (o) => !o.custom\n  ) as Array<Option>\n\n  const buildId = (value: string) => {\n    return `${id}-${slugify(value)}`\n  }\n\n  const buildOptionRegister = (o: Option) => {\n    const id = buildId(o.label)\n    const registerOption = (options: RegisterOptions) => ({\n      ...register({ ...options }),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  }\n\n  const result = {\n    options: nonCustomOptions.map(buildOptionRegister)\n  } as UseCustomOptionReturn\n\n  const customOption = field.options.find((o) => o.custom) as Option\n  if (customOption) {\n    const id = buildId(OTHER_OPTION)\n    const registerOption = (options = {}) => ({\n      ...register({ ...options }),\n      value: OTHER_OPTION\n    })\n\n    const customOptionId = buildCustomFieldId(id)\n\n    const registerCustomInput = (options = {}) => {\n      return context!.register(customOptionId, {\n        required: customInputRequired,\n        ...options\n      })\n    }\n\n    const error = context!.formState.errors[customOptionId]\n\n    result.customOption = {\n      ...customOption,\n      id,\n      registerOption,\n      registerCustomInput,\n      error\n    }\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  return {\n    ...(field as BaseField),\n    ...result,\n    error\n  }\n}\n","import { useForm } from 'react-hook-form'\nimport queryString from 'query-string'\nimport axios from 'axios'\n\nimport {\n  OTHER_OPTION,\n  OTHER_OPTION_RESPONSE\n} from './utils/useCustomOptionField'\nimport { GoogleForm, UseGoogleFormReturn } from '../types'\n\nconst GOOGLE_FORMS_URL = 'https://docs.google.com/forms/d'\n\nconst resolveField = (id: string, form: GoogleForm) => {\n  const fieldIndex = form.fieldsOrder[id]\n\n  if (fieldIndex === undefined) {\n    throw new Error(`Field with id ${id} wasn't found in your form`)\n  }\n\n  const field = form.fields[fieldIndex]\n  return field\n}\n\nexport const formatQuestionName = (id: string) => {\n  if (id.includes(OTHER_OPTION_RESPONSE)) {\n    return `entry.${id.replace(\n      `-${OTHER_OPTION}-${OTHER_OPTION_RESPONSE}`,\n      ''\n    )}.${OTHER_OPTION_RESPONSE}`\n  }\n\n  return `entry.${id}`\n}\n\nexport const useGoogleForm = ({ form }: { form: GoogleForm }) => {\n  const methods = useForm() as UseGoogleFormReturn\n\n  methods.getField = (id: string) => resolveField(id, form)\n\n  const submitToGoogleForms = async (formData: object) => {\n    const fields = {}\n    Object.keys(formData).forEach((key) => {\n      fields[formatQuestionName(key)] = formData[key]\n    })\n\n    const params = queryString.stringify(fields, {\n      skipNull: true,\n      skipEmptyString: true\n    })\n\n    try {\n      await axios.get(\n        `${GOOGLE_FORMS_URL}/${form.action}/formResponse?${params}&submit=Submit`,\n        {\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          }\n        }\n      )\n    } catch (err) {\n      // We need to catch the error here because of CORS\n      // However the form will still be submitted to Google Forms if every field is correct\n      // Otherwise we don't have observability if the form submission failed.\n      // TODO: we could implement the suggestion on this stackoverflow about having an invisible iframe\n      // to perform the submission https://stackoverflow.com/a/61359999/13194919\n      return\n    }\n  }\n\n  methods.submitToGoogleForms = submitToGoogleForms\n\n  return methods\n}\n","import { RegisterOptions } from 'react-hook-form'\n\nimport { UseTextFieldReturn, TextField } from '../../types'\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\n\nexport default (\n  id: string,\n  fieldType: 'LONG_ANSWER' | 'SHORT_ANSWER'\n): UseTextFieldReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, fieldType) as TextField\n\n  const error = context!.formState.errors[field.id]\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  return { ...field, register, error }\n}\n","import { useEffect, useState } from 'react'\nimport { RegisterOptions } from 'react-hook-form'\nimport slugify from 'slugify'\n\nimport { useGoogleFormContext } from '../useGoogleFormContext'\nimport getFieldFromContext from './getFieldFromContext'\nimport {\n  UseGridFieldReturn,\n  GridField,\n  RenderLineFunction,\n  RenderColumnFunction,\n  GridErrors\n} from '../../types'\n\nexport default (\n  id: string,\n  type: 'RADIO_GRID' | 'CHECKBOX_GRID'\n): UseGridFieldReturn => {\n  const context = useGoogleFormContext()\n  const [errors, setErrors] = useState<GridErrors | undefined>(undefined)\n\n  const field = getFieldFromContext(context, id, type) as GridField\n\n  const buildId = (lineId: string, value: string) => {\n    return `${id}-${lineId}-${slugify(value)}`\n  }\n\n  useEffect(() => {\n    const newErrors: GridErrors = field.lines.reduce((acc: GridErrors, l) => {\n      const fieldError = context!.formState.errors[l.id]\n      if (fieldError) {\n        acc[l.id] = fieldError\n      }\n      return acc\n    }, {})\n\n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors)\n    } else {\n      setErrors(undefined)\n    }\n  }, [context!.formState.errors])\n\n  const renderGrid = (render: RenderLineFunction): JSX.Element[] => {\n    return field.lines.map((l) => {\n      const registerLine = (options?: RegisterOptions) =>\n        context!.register(l.id, { required: field.required, ...options })\n\n      const renderColumns = (render: RenderColumnFunction): JSX.Element[] => {\n        return field.columns.map((c) => {\n          const id = buildId(l.id, c.label)\n          const registerColumn = (options?: RegisterOptions) => ({\n            ...registerLine(options),\n            value: c.label\n          })\n\n          return render({ ...c, registerColumn, id })\n        })\n      }\n\n      return render({ ...l, renderColumns })\n    })\n  }\n\n  return { ...field, renderGrid, errors }\n}\n","import slugify from 'slugify'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseDropdownReturn, DropdownField } from '../types'\nimport { RegisterOptions } from 'react-hook-form'\n\nexport const useDropdownInput = (id: string): UseDropdownReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'DROPDOWN') as DropdownField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const error = context!.formState.errors[field.id]\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    return {\n      ...o,\n      id\n    }\n  })\n\n  return { ...field, options, register, error }\n}\n","import slugify from 'slugify'\nimport { RegisterOptions } from 'react-hook-form'\n\nimport { useGoogleFormContext } from './useGoogleFormContext'\nimport getFieldFromContext from './utils/getFieldFromContext'\nimport { UseLinearInputReturn, LinearField } from '../types'\n\nexport const useLinearInput = (id: string): UseLinearInputReturn => {\n  const context = useGoogleFormContext()\n\n  const field = getFieldFromContext(context, id, 'LINEAR') as LinearField\n\n  const register = (options?: RegisterOptions) =>\n    context!.register(id, { required: field.required, ...options })\n\n  const buildId = (value: string) => {\n    return `${field.id}-${slugify(value)}`\n  }\n\n  const error = context!.formState.errors[field.id]\n\n  const options = field.options.map((o) => {\n    const id = buildId(o.label)\n    const registerOption = (options?: RegisterOptions) => ({\n      ...register(options),\n      value: o.label\n    })\n\n    return {\n      ...o,\n      id,\n      registerOption\n    }\n  })\n\n  return { ...field, options, error }\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { useCheckboxInput } from 'react-google-forms'\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: column;\n`\n\nconst CheckboxContainer = styled.div`\n  display: flex;\n\n  & label {\n    margin: 0 10px;\n  }\n`\n\nexport default function CheckboxInput({ id }) {\n  const { options, customOption } = useCheckboxInput(id)\n\n  return (\n    <Container>\n      {options.map((o) => (\n        <CheckboxContainer key={o.id}>\n          <input type='checkbox' id={o.id} {...o.registerOption()} />\n          <label htmlFor={o.id}>{o.label}</label>\n        </CheckboxContainer>\n      ))}\n      {customOption && (\n        <CheckboxContainer>\n          <input\n            type='checkbox'\n            id={customOption.id}\n            {...customOption.registerOption()}\n          />\n          <label htmlFor={customOption.id}>Outra</label>\n          <input\n            type='text'\n            placeholder='Resposta aqui'\n            {...customOption.registerCustomInput()}\n          />\n        </CheckboxContainer>\n      )}\n    </Container>\n  )\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useCheckboxInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'CHECKBOX')\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { useRadioInput } from 'react-google-forms'\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: column;\n`\n\nconst CheckboxContainer = styled.div`\n  display: flex;\n\n  & label {\n    margin: 0 10px;\n  }\n`\n\nconst ErrorLabel = styled.span`\n  color: red;\n  padding: 10px 0;\n`\n\nexport default function RadioInput({ id }) {\n  const { options, customOption, error } = useRadioInput(id)\n\n  return (\n    <Container>\n      {options.map((o) => (\n        <CheckboxContainer key={o.id}>\n          <input type='radio' id={o.id} {...o.registerOption()} />\n          <label htmlFor={o.id}>{o.label}</label>\n        </CheckboxContainer>\n      ))}\n      {customOption && (\n        <CheckboxContainer>\n          <input\n            type='radio'\n            id={customOption.id}\n            {...customOption.registerOption()}\n          />\n          <label htmlFor={customOption.id}>Outra</label>\n          <input\n            type='text'\n            placeholder='Resposta aqui'\n            {...customOption.registerCustomInput()}\n          />\n        </CheckboxContainer>\n      )}\n      <ErrorLabel>{error && 'This field is required'}</ErrorLabel>\n    </Container>\n  )\n}\n","import useCustomOptionField from './utils/useCustomOptionField'\nimport { UseCustomOptionField } from '../types'\n\nexport const useRadioInput = (id: string): UseCustomOptionField => {\n  return useCustomOptionField(id, 'RADIO')\n}\n","import React from 'react'\n\nimport { useShortAnswerInput } from 'react-google-forms'\n\nexport default function ShortAnswerInput({ id }) {\n  const { register } = useShortAnswerInput(id)\n\n  return (\n    <div>\n      <input type='text' {...register()} />\n    </div>\n  )\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useShortAnswerInput = (id: string) => {\n  return useTextInput(id, 'SHORT_ANSWER')\n}\n","import React from 'react'\n\nimport { useLongAnswerInput } from 'react-google-forms'\n\nexport default function LongAnswerInput({ id }) {\n  const { register } = useLongAnswerInput(id)\n\n  return (\n    <div>\n      <textarea type='text' {...register()} />\n    </div>\n  )\n}\n","import useTextInput from './utils/useTextInput'\n\nexport const useLongAnswerInput = (id: string) => {\n  return useTextInput(id, 'LONG_ANSWER')\n}\n","import React from 'react'\nimport { useRadioGridInput } from 'react-google-forms'\nimport styled from 'styled-components'\n\nconst GridQuestionContainer = styled.div`\n  display: table;\n`\n\nconst TableHeader = styled.header`\n  display: table-row;\n`\n\nconst TableRow = styled.div`\n  display: table-row;\n`\n\nconst TableCell = styled.div`\n  display: table-cell;\n  padding: 5px;\n`\n\nexport default function RadioGridInput({ id }) {\n  const { columns, renderGrid } = useRadioGridInput(id)\n\n  return (\n    <GridQuestionContainer>\n      <TableHeader>\n        <TableCell />\n        {columns.map((c) => (\n          <TableCell key={c.label}>{c.label}</TableCell>\n        ))}\n      </TableHeader>\n      {renderGrid((l) => (\n        <TableRow key={l.label}>\n          <TableCell>{l.label}</TableCell>\n          {l.renderColumns((c) => (\n            <TableCell key={c.label}>\n              <input type='radio' {...c.registerColumn()} />\n            </TableCell>\n          ))}\n        </TableRow>\n      ))}\n    </GridQuestionContainer>\n  )\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useRadioGridInput = (id: string) => {\n  return useGridInput(id, 'RADIO_GRID')\n}\n","import React from 'react'\nimport { useCheckboxGridInput } from 'react-google-forms'\nimport styled from 'styled-components'\n\nconst GridQuestionContainer = styled.div`\n  display: table;\n`\n\nconst TableHeader = styled.header`\n  display: table-row;\n`\n\nconst TableRow = styled.div`\n  display: table-row;\n`\n\nconst TableCell = styled.div`\n  display: table-cell;\n  padding: 5px;\n`\n\nexport default function CheckboxGridInput({ id }) {\n  const { columns, renderGrid } = useCheckboxGridInput(id)\n\n  return (\n    <GridQuestionContainer>\n      <TableHeader>\n        <TableCell />\n        {columns.map((c) => (\n          <TableCell key={c.label}>{c.label}</TableCell>\n        ))}\n      </TableHeader>\n      {renderGrid((l) => (\n        <TableRow key={l.label}>\n          <TableCell>{l.label}</TableCell>\n          {l.renderColumns((c) => (\n            <TableCell key={c.label}>\n              <input type='checkbox' {...c.registerColumn()} />\n            </TableCell>\n          ))}\n        </TableRow>\n      ))}\n    </GridQuestionContainer>\n  )\n}\n","import useGridInput from './utils/useGridInput'\n\nexport const useCheckboxGridInput = (id: string) => {\n  return useGridInput(id, 'CHECKBOX_GRID')\n}\n","import React from 'react'\n\nimport { useDropdownInput } from 'react-google-forms'\n\nexport default function DropdownInput({ id }) {\n  const { register, options } = useDropdownInput(id)\n\n  return (\n    <div>\n      <select {...register()}>\n        <option value=''>Select option</option>\n        {options.map((o) => {\n          return (\n            <option key={o.label} value={o.label}>\n              {o.label}\n            </option>\n          )\n        })}\n      </select>\n    </div>\n  )\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { useLinearInput } from 'react-google-forms'\n\nconst Container = styled.div`\n  display: flex;\n  align-items: center;\n\n  & * {\n    margin: 0 10px;\n  }\n  margin-bottom 10px;\n`\n\nconst ErrorLabel = styled.span`\n  color: red;\n`\n\nexport default function ShortAnswerInput({ id }) {\n  const { options, legend, error } = useLinearInput(id)\n\n  return (\n    <>\n      <Container>\n        <div>{legend.labelFirst}</div>\n        {options.map((o) => {\n          return <input key={o.id} type='radio' {...o.registerOption()} />\n        })}\n        <div>{legend.labelLast}</div>\n      </Container>\n      <ErrorLabel>{error && 'This field is required'}</ErrorLabel>\n    </>\n  )\n}\n","import React from 'react'\nimport styled from 'styled-components'\n\nimport { GoogleFormProvider, useGoogleForm } from 'react-google-forms'\n\nimport form from './scripts/form.json'\n\nimport CheckboxInput from './components/CheckboxInput'\nimport RadioInput from './components/RadioInput'\nimport ShortAnswerInput from './components/ShortAnswerInput'\nimport LongAnswerInput from './components/LongAnswerInput'\nimport RadioGridInput from './components/RadioGridInput'\nimport CheckboxGridInput from './components/CheckboxGridInput'\nimport DropdownInput from './components/DropdownInput'\nimport LinearGrid from './components/LinearGrid'\n\nconst Form = styled.form`\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 50px 0;\n`\n\nconst QuestionContainer = styled.div`\n  margin-bottom: 20px;\n`\n\nconst QuestionLabel = styled.h3`\n  margin-bottom: 10px;\n`\n\nconst Questions = () => {\n  return (\n    <div>\n      {form.fields.map((field) => {\n        const { id } = field\n\n        let questionInput = null\n        switch (field.type) {\n          case 'CHECKBOX':\n            questionInput = <CheckboxInput id={id} />\n            break\n          case 'RADIO':\n            questionInput = <RadioInput id={id} />\n            break\n          case 'SHORT_ANSWER':\n            questionInput = <ShortAnswerInput id={id} />\n            break\n          case 'LONG_ANSWER':\n            questionInput = <LongAnswerInput id={id} />\n            break\n          case 'RADIO_GRID':\n            questionInput = <RadioGridInput id={id} />\n            break\n          case 'CHECKBOX_GRID':\n            questionInput = <CheckboxGridInput id={id} />\n            break\n          case 'DROPDOWN':\n            questionInput = <DropdownInput id={id} />\n            break\n          case 'LINEAR':\n            questionInput = <LinearGrid id={id} />\n            break\n        }\n\n        if (!questionInput) {\n          return null\n        }\n\n        return (\n          <QuestionContainer key={id}>\n            <QuestionLabel>{field.label}</QuestionLabel>\n            {questionInput}\n          </QuestionContainer>\n        )\n      })}\n    </div>\n  )\n}\n\nconst App = () => {\n  const methods = useGoogleForm({ form })\n  const onSubmit = async (data) => {\n    console.log('>>> Here is the data', data)\n    await methods.submitToGoogleForms(data)\n    alert('Form submitted with success!')\n  }\n\n  console.log('>>> Here are the errors!!!', methods.formState.errors)\n\n  return (\n    <GoogleFormProvider {...methods}>\n      <Form onSubmit={methods.handleSubmit(onSubmit)}>\n        <Questions />\n        <button type='submit'>Submeter</button>\n      </Form>\n    </GoogleFormProvider>\n  )\n}\n\nexport default App\n","/* global document */\nimport './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}